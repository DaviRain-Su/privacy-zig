//! Groth16 Zero-Knowledge Proof Verification
//!
//! This module implements Groth16 verification using Solana's alt_bn128 syscalls.
//! Compatible with snarkjs/circom generated proofs.
//!
//! ## On-chain Verification
//!
//! The Groth16 verification equation is:
//!   e(A, B) = e(α, β) · e(vk_x, γ) · e(C, δ)
//!
//! Where vk_x = IC[0] + Σ(public_inputs[i] * IC[i+1])
//!
//! This is transformed to a single pairing check:
//!   e(-A, B) · e(α, β) · e(vk_x, γ) · e(C, δ) = 1
//!
//! ## Proof Format (snarkjs compatible)
//!
//! - A: G1 point (64 bytes)
//! - B: G2 point (128 bytes)  
//! - C: G1 point (64 bytes)
//! Total: 256 bytes

const std = @import("std");
const sol = @import("solana_program_sdk");
const bn254 = sol.bn254;

// ============================================================================
// Constants
// ============================================================================

/// Size of a G1 point (64 bytes)
pub const G1_SIZE: usize = 64;

/// Size of a G2 point (128 bytes)
pub const G2_SIZE: usize = 128;

/// Size of a scalar field element (32 bytes)
pub const SCALAR_SIZE: usize = 32;

/// Size of a complete Groth16 proof (A + B + C = 256 bytes)
pub const PROOF_SIZE: usize = G1_SIZE + G2_SIZE + G1_SIZE;

/// Size of one pairing element (G1 + G2 = 192 bytes)
pub const PAIRING_ELEMENT_SIZE: usize = G1_SIZE + G2_SIZE;

// ============================================================================
// Verification Key
// ============================================================================

/// Groth16 verification key
///
/// Generated by snarkjs/circom during trusted setup.
/// Contains the public parameters needed to verify proofs.
pub const VerificationKey = struct {
    /// α in G1 (64 bytes, big-endian)
    alpha_g1: [G1_SIZE]u8,

    /// β in G2 (128 bytes, big-endian)
    beta_g2: [G2_SIZE]u8,

    /// γ in G2 (128 bytes, big-endian)
    gamma_g2: [G2_SIZE]u8,

    /// δ in G2 (128 bytes, big-endian)
    delta_g2: [G2_SIZE]u8,

    /// IC points (IC[0], IC[1], ..., IC[n]) where n = number of public inputs
    /// Each is a G1 point (64 bytes, big-endian)
    ic: []const [G1_SIZE]u8,

    /// Number of public inputs
    pub fn numPublicInputs(self: *const VerificationKey) usize {
        return self.ic.len - 1;
    }
};

// ============================================================================
// Proof
// ============================================================================

/// Groth16 proof (256 bytes)
///
/// Generated by the prover using the witness and proving key.
pub const Proof = struct {
    /// A point in G1 (64 bytes)
    a: [G1_SIZE]u8,

    /// B point in G2 (128 bytes)
    b: [G2_SIZE]u8,

    /// C point in G1 (64 bytes)
    c: [G1_SIZE]u8,

    /// Create from raw bytes (snarkjs format)
    pub fn fromBytes(bytes: [PROOF_SIZE]u8) Proof {
        return .{
            .a = bytes[0..G1_SIZE].*,
            .b = bytes[G1_SIZE..][0..G2_SIZE].*,
            .c = bytes[G1_SIZE + G2_SIZE ..][0..G1_SIZE].*,
        };
    }

    /// Serialize to bytes
    pub fn toBytes(self: *const Proof) [PROOF_SIZE]u8 {
        var bytes: [PROOF_SIZE]u8 = undefined;
        @memcpy(bytes[0..G1_SIZE], &self.a);
        @memcpy(bytes[G1_SIZE..][0..G2_SIZE], &self.b);
        @memcpy(bytes[G1_SIZE + G2_SIZE ..][0..G1_SIZE], &self.c);
        return bytes;
    }
};

// ============================================================================
// Verification
// ============================================================================

/// Error types for Groth16 verification
pub const Groth16Error = error{
    /// Invalid proof format
    InvalidProof,
    /// Invalid public inputs
    InvalidPublicInputs,
    /// Proof verification failed
    VerificationFailed,
    /// Elliptic curve operation failed
    CurveError,
    /// IC length mismatch
    ICLengthMismatch,
};

/// Verify a Groth16 proof
///
/// This function performs the full Groth16 verification using Solana's
/// alt_bn128 syscalls for efficient on-chain execution.
///
/// Parameters:
/// - vk: Verification key from trusted setup
/// - proof: The Groth16 proof to verify
/// - public_inputs: Public inputs (field elements, 32 bytes each, big-endian)
///
/// Returns true if the proof is valid, false otherwise.
pub fn verify(
    vk: *const VerificationKey,
    proof: *const Proof,
    public_inputs: []const [SCALAR_SIZE]u8,
) Groth16Error!bool {
    // Check IC length matches public inputs
    if (public_inputs.len + 1 != vk.ic.len) {
        return Groth16Error.ICLengthMismatch;
    }

    // Step 1: Compute vk_x = IC[0] + Σ(public_inputs[i] * IC[i+1])
    var vk_x: [G1_SIZE]u8 = vk.ic[0];

    for (public_inputs, 0..) |input, i| {
        // Scalar multiplication: input * IC[i+1]
        var mul_input: [G1_SIZE + SCALAR_SIZE]u8 = undefined;
        @memcpy(mul_input[0..G1_SIZE], &vk.ic[i + 1]);
        @memcpy(mul_input[G1_SIZE..], &input);

        var mul_result: [G1_SIZE]u8 = undefined;
        bn254.g1MultiplicationBE(&mul_input, &mul_result) catch {
            return Groth16Error.CurveError;
        };

        // Point addition: vk_x + mul_result
        var add_input: [G1_SIZE * 2]u8 = undefined;
        @memcpy(add_input[0..G1_SIZE], &vk_x);
        @memcpy(add_input[G1_SIZE..], &mul_result);

        bn254.g1AdditionBE(&add_input, &vk_x) catch {
            return Groth16Error.CurveError;
        };
    }

    // Step 2: Negate A (for pairing equation)
    // -A = (A.x, -A.y mod p)
    var neg_a: [G1_SIZE]u8 = undefined;
    negateG1BE(&proof.a, &neg_a);

    // Step 3: Construct pairing input
    // e(-A, B) · e(α, β) · e(vk_x, γ) · e(C, δ) = 1
    //
    // Pairing input format: [(G1, G2), (G1, G2), (G1, G2), (G1, G2)]
    const num_pairs = 4;
    var pairing_input: [num_pairs * PAIRING_ELEMENT_SIZE]u8 = undefined;

    // Pair 1: (-A, B)
    @memcpy(pairing_input[0..G1_SIZE], &neg_a);
    @memcpy(pairing_input[G1_SIZE..][0..G2_SIZE], &proof.b);

    // Pair 2: (α, β)
    const pair2_offset = PAIRING_ELEMENT_SIZE;
    @memcpy(pairing_input[pair2_offset..][0..G1_SIZE], &vk.alpha_g1);
    @memcpy(pairing_input[pair2_offset + G1_SIZE ..][0..G2_SIZE], &vk.beta_g2);

    // Pair 3: (vk_x, γ)
    const pair3_offset = 2 * PAIRING_ELEMENT_SIZE;
    @memcpy(pairing_input[pair3_offset..][0..G1_SIZE], &vk_x);
    @memcpy(pairing_input[pair3_offset + G1_SIZE ..][0..G2_SIZE], &vk.gamma_g2);

    // Pair 4: (C, δ)
    const pair4_offset = 3 * PAIRING_ELEMENT_SIZE;
    @memcpy(pairing_input[pair4_offset..][0..G1_SIZE], &proof.c);
    @memcpy(pairing_input[pair4_offset + G1_SIZE ..][0..G2_SIZE], &vk.delta_g2);

    // Step 4: Pairing check
    const result = bn254.pairingBE(&pairing_input) catch {
        return Groth16Error.CurveError;
    };

    return result;
}

/// Negate a G1 point (big-endian format)
///
/// For BN254: -P = (P.x, -P.y mod p)
/// p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
fn negateG1BE(point: *const [G1_SIZE]u8, result: *[G1_SIZE]u8) void {
    // Copy x coordinate (unchanged)
    @memcpy(result[0..32], point[0..32]);

    // Negate y coordinate: -y = p - y (mod p)
    // BN254 prime p in big-endian
    const p: [32]u8 = .{
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29,
        0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d,
        0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
    };

    // Compute p - y using big integer subtraction
    var borrow: u16 = 0;
    var y_neg: [32]u8 = undefined;
    for (0..32) |i| {
        const idx = 31 - i;
        const diff: i32 = @as(i32, p[idx]) - @as(i32, point[32 + idx]) - @as(i32, @as(u16, @intCast(borrow)));
        if (diff < 0) {
            y_neg[idx] = @truncate(@as(u32, @intCast(diff + 256)));
            borrow = 1;
        } else {
            y_neg[idx] = @truncate(@as(u32, @intCast(diff)));
            borrow = 0;
        }
    }

    @memcpy(result[32..64], &y_neg);
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Convert a u256 (big-endian bytes) to scalar format
pub fn u256ToScalar(value: [32]u8) [SCALAR_SIZE]u8 {
    return value;
}

/// Convert a u64 to scalar format (big-endian, zero-padded)
pub fn u64ToScalar(value: u64) [SCALAR_SIZE]u8 {
    var result: [SCALAR_SIZE]u8 = [_]u8{0} ** SCALAR_SIZE;
    std.mem.writeInt(u64, result[24..32], value, .big);
    return result;
}

/// Convert an i128 to scalar format (big-endian, handles negative)
pub fn i128ToScalar(value: i128) [SCALAR_SIZE]u8 {
    var result: [SCALAR_SIZE]u8 = undefined;
    if (value >= 0) {
        result = [_]u8{0} ** SCALAR_SIZE;
        const abs: u128 = @intCast(value);
        std.mem.writeInt(u128, result[16..32], abs, .big);
    } else {
        // For negative values, compute field_order - |value|
        // This is a simplification; proper implementation needs full modular arithmetic
        result = [_]u8{0xff} ** SCALAR_SIZE;
        const abs: u128 = @intCast(-value);
        std.mem.writeInt(u128, result[16..32], abs, .big);
    }
    return result;
}

// ============================================================================
// Tests
// ============================================================================

test "groth16: proof serialization" {
    const proof_bytes = [_]u8{0x42} ** PROOF_SIZE;
    const proof = Proof.fromBytes(proof_bytes);

    try std.testing.expectEqual(@as(usize, G1_SIZE), proof.a.len);
    try std.testing.expectEqual(@as(usize, G2_SIZE), proof.b.len);
    try std.testing.expectEqual(@as(usize, G1_SIZE), proof.c.len);

    const serialized = proof.toBytes();
    try std.testing.expectEqualSlices(u8, &proof_bytes, &serialized);
}

test "groth16: u64 to scalar" {
    const scalar = u64ToScalar(123456789);
    try std.testing.expectEqual(@as(u8, 0), scalar[0]);
    try std.testing.expectEqual(@as(u8, 0), scalar[23]);

    // Check big-endian encoding
    var expected: [8]u8 = undefined;
    std.mem.writeInt(u64, &expected, 123456789, .big);
    try std.testing.expectEqualSlices(u8, &expected, scalar[24..32]);
}

test "groth16: G1 negation" {
    // Test with a simple point (not actually on curve, just for format testing)
    const point: [G1_SIZE]u8 = [_]u8{0x01} ** 32 ++ [_]u8{0x02} ** 32;
    var negated: [G1_SIZE]u8 = undefined;
    negateG1BE(&point, &negated);

    // X should be unchanged
    try std.testing.expectEqualSlices(u8, point[0..32], negated[0..32]);

    // Y should be different (negated)
    try std.testing.expect(!std.mem.eql(u8, point[32..64], negated[32..64]));
}

test "groth16: verification key structure" {
    const ic = [_][G1_SIZE]u8{
        [_]u8{0} ** G1_SIZE,
        [_]u8{1} ** G1_SIZE,
        [_]u8{2} ** G1_SIZE,
    };

    const vk = VerificationKey{
        .alpha_g1 = [_]u8{0} ** G1_SIZE,
        .beta_g2 = [_]u8{0} ** G2_SIZE,
        .gamma_g2 = [_]u8{0} ** G2_SIZE,
        .delta_g2 = [_]u8{0} ** G2_SIZE,
        .ic = &ic,
    };

    try std.testing.expectEqual(@as(usize, 2), vk.numPublicInputs());
}
